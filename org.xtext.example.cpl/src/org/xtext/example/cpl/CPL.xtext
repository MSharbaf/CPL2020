grammar org.xtext.example.cpl.CPL  with org.eclipse.ocl.xtext.essentialocl.EssentialOCL //with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/ocl/2015/BaseCS" as base
//import "platform:/resource/org.xtext.example.mydsl/model/BaseCS.ecore" as base

import "http://www.eclipse.org/ocl/2015/Pivot" as pivot
//import "platform:/resource/org.eclipse.ocl.pivot/model/Pivot.ecore" as pivot

import "http://www.eclipse.org/ocl/2015/EssentialOCLCS" as essentialocl
//import "platform:/resource/org.eclipse.ocl.xtext.essentialocl/model/EssentialOCLCS.ecore" as essentialocl

generate cPL "http://www.xtext.org/example/cpl/CPL"
	
TopLevelCP returns TopLevelCP:
	'conflict' name=Identifier '{'
		ownedImports+=DomainCP*
		(ownedDomains+=ImportCP)+
		(ownedFragments+=FragmentCP)+
		(ownedRelation+=RelationCP)*
		ownedMessage+=MessageCP
	'}'
;

MessageCP:
	'message' '{' ownedExpression=StringLiteral '}'
;

RelationCP:
	'where' '{' ('or'|'and')? ownedStatement=StatementCS '}' 
;

StatementCS:
	'stmt' ownedstatement+=ConstraintCS
;

FragmentCP:
	('inmodel' name=UnrestrictedName '{') (ownedContexts+=ContextDeclCS)+ ('}')
;

terminal UNQUOTED_STRING:	// Never forward parsed; just provides a placeholder
	'£$%^£$%^'				//  for reverse serialisation of embedded OCL 
;


DomainCP:
	'domain' (name=Identifier ':')? nsURI=URI /*ownedPathName=PathNameCS /* ownedPathName=Base::URI ownedPathElements+=URIFirstPathElementCS  =URIPathNameCS /*(isAll?='::*')?*/ ';'
;

ImportCP returns base::ImportCS:
	('import' | 'include' | 'library') (name=Identifier ':')? ownedPathName=URIPathNameCS (isAll?='::*')?;

PatternCP returns base::PackageCS:
	'pattern' name=UnrestrictedName
//	(':' nsPrefix=UnrestrictedName)? ('=' nsURI=URI)?
	(('{'
		(ownedAnnotations+=AnnotationElementCS)* // | ownedPackages+=PackageCS | ownedClasses+=ClassCS)*
		'}')
	|';'
	)
;

AnnotationCS returns base::AnnotationCS:
	{base::AnnotationCS} 'annotation' name=(UnrestrictedName|SINGLE_QUOTED_STRING)?
//	('(' ownedDetails+=DetailCS (',' ownedDetails+=DetailCS)* ')')?
	(('{' (ownedAnnotations+=AnnotationElementCS
//	     | ownedContents+=ModelElementCS
	     | ownedReferences+=ModelElementRefCS
	  )+'}')
	|';'
	)
;

AnnotationElementCS returns base::AnnotationElementCS:
	AnnotationCS | DocumentationCS //| SysMLCS
;

ModelElementRefCS returns base::ModelElementRefCS:
	'reference' ownedPathName=PathNameCS ';'
;

DetailCS returns base::DetailCS:
	name=(UnrestrictedName|SINGLE_QUOTED_STRING) '=' values+=(SINGLE_QUOTED_STRING|ML_SINGLE_QUOTED_STRING)*
;

DocumentationCS returns base::DocumentationCS:
	{base::DocumentationCS} 'documentation' value=SINGLE_QUOTED_STRING?
	('(' ownedDetails+=DetailCS (',' ownedDetails+=DetailCS)* ')')?
	 ';'
;

//*******************************

ClassifierContextDeclCS returns ClassifierContextDeclCS:
	'context' (ownedSignature=TemplateSignatureCS)? (selfName=UnrestrictedName)?
	ownedPathName=PathNameCS	
	(('inv' ownedInvariants+=ConstraintCS)
	| ownedDefinitions+=DefCS
	)+;


ConstraintCS returns base::ConstraintCS:
	(name=UnrestrictedName ('(' ownedMessageSpecification=SpecificationCS ')')?)? ':' ownedSpecification=SpecificationCS;

/*
 * A Context declaration can be a Classifier, Operation of Property Context declaration.
 */
ContextDeclCS returns ContextDeclCS:
//	PropertyContextDeclCS | 
	ClassifierContextDeclCS
//	| OperationContextDeclCS
	;

/*
 * A definition can be an, Operation or Property definition.
 */
DefCS returns DefCS:
	DefOperationCS|DefPropertyCS;
	
	
SpecificationCS returns essentialocl::ExpSpecificationCS:
	ownedExpression=ExpCS | exprString=UNQUOTED_STRING;
	
	
DefOperationCS returns DefOperationCS:
	(isStatic?='static')? 'def' UnrestrictedName? ':' (ownedSignature=TemplateSignatureCS)?
		name=UnrestrictedName '(' (ownedParameters+=DefParameterCS (',' ownedParameters+=DefParameterCS)*)? ')' ':' (ownedType=TypeExpCS)?
		 '=' ownedSpecification=SpecificationCS;
		 
DefPropertyCS returns DefPropertyCS:
	(isStatic?='static')? 'def' UnrestrictedName? ':' name=UnrestrictedName ':' ownedType=TypeExpCS
		'=' ownedSpecification=SpecificationCS;
	
DefParameterCS returns base::ParameterCS:
	name=UnrestrictedName ':' ownedType=TypeExpCS;

EnumerationLiteralName returns ecore::EString:
	EssentialOCLUnrestrictedName
|	'abstract'
|	'attribute'
|	'body'
|	'callable'
|	'class'
|	'composes'
|	'datatype'
|	'definition'
|	'derivation'
|	'derived'
|	'enum'
|	'extends'
|	'id'
|	'import'
|	'initial'
|	'interface'
|	'key'
|	'library'
|	'module'
|	'operation'
|	'ordered'
|	'package'
|	'postcondition'
|	'precondition'
|	'primitive'
|	'property'
|	'readonly'
|	'reference'
|	'resolve'
|	'static'
|	'throws'
|	'transient'
|	'unique'
|	'unsettable'
|	'volatile'
;