/*
 * generated by Xtext 2.14.0
 */
package org.xtext.example.cpl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.ocl.xtext.base.services.BaseGrammarAccess;
import org.eclipse.ocl.xtext.completeocl.services.CompleteOCLGrammarAccess;
import org.eclipse.ocl.xtext.essentialocl.services.EssentialOCLGrammarAccess;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class CPLGrammarAccess extends AbstractGrammarElementFinder {
	
	public class TopLevelCPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cpl.CPL.TopLevelCP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConflictKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOwnedImportsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOwnedImportsImportCPParserRuleCall_3_0 = (RuleCall)cOwnedImportsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cInmodelKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cUnrestrictedNameParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		private final Assignment cOwnedContextsAssignment_4_3 = (Assignment)cGroup_4.eContents().get(3);
		private final RuleCall cOwnedContextsContextDeclCSParserRuleCall_4_3_0 = (RuleCall)cOwnedContextsAssignment_4_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4_4 = (Keyword)cGroup_4.eContents().get(4);
		private final Assignment cOwnedRelationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cOwnedRelationRelationCPParserRuleCall_5_0 = (RuleCall)cOwnedRelationAssignment_5.eContents().get(0);
		private final Assignment cOwnedMessageAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cOwnedMessageMessageCPParserRuleCall_6_0 = (RuleCall)cOwnedMessageAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//TopLevelCP:
		//	'conflict' name=Identifier '{'
		//	ownedImports+=ImportCP+ ('inmodel' UnrestrictedName '{' ownedContexts+=ContextDeclCS+ '}')+
		//	ownedRelation+=RelationCP?
		//	ownedMessage+=MessageCP?
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'conflict' name=Identifier '{' ownedImports+=ImportCP+ ('inmodel' UnrestrictedName '{' ownedContexts+=ContextDeclCS+
		//'}')+ ownedRelation+=RelationCP? ownedMessage+=MessageCP? '}'
		public Group getGroup() { return cGroup; }
		
		//'conflict'
		public Keyword getConflictKeyword_0() { return cConflictKeyword_0; }
		
		//name=Identifier
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_1_0() { return cNameIdentifierParserRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//ownedImports+=ImportCP+
		public Assignment getOwnedImportsAssignment_3() { return cOwnedImportsAssignment_3; }
		
		//ImportCP
		public RuleCall getOwnedImportsImportCPParserRuleCall_3_0() { return cOwnedImportsImportCPParserRuleCall_3_0; }
		
		//('inmodel' UnrestrictedName '{' ownedContexts+=ContextDeclCS+ '}')+
		public Group getGroup_4() { return cGroup_4; }
		
		//'inmodel'
		public Keyword getInmodelKeyword_4_0() { return cInmodelKeyword_4_0; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_4_1() { return cUnrestrictedNameParserRuleCall_4_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4_2() { return cLeftCurlyBracketKeyword_4_2; }
		
		//ownedContexts+=ContextDeclCS+
		public Assignment getOwnedContextsAssignment_4_3() { return cOwnedContextsAssignment_4_3; }
		
		//ContextDeclCS
		public RuleCall getOwnedContextsContextDeclCSParserRuleCall_4_3_0() { return cOwnedContextsContextDeclCSParserRuleCall_4_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4_4() { return cRightCurlyBracketKeyword_4_4; }
		
		//ownedRelation+=RelationCP?
		public Assignment getOwnedRelationAssignment_5() { return cOwnedRelationAssignment_5; }
		
		//RelationCP
		public RuleCall getOwnedRelationRelationCPParserRuleCall_5_0() { return cOwnedRelationRelationCPParserRuleCall_5_0; }
		
		//ownedMessage+=MessageCP?
		public Assignment getOwnedMessageAssignment_6() { return cOwnedMessageAssignment_6; }
		
		//MessageCP
		public RuleCall getOwnedMessageMessageCPParserRuleCall_6_0() { return cOwnedMessageMessageCPParserRuleCall_6_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class ImportCPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cpl.CPL.ImportCP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cImportKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cDomainKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cNameIdentifierParserRuleCall_1_0_0 = (RuleCall)cNameAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cOwnedPathNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOwnedPathNameURIPathNameCSParserRuleCall_2_0 = (RuleCall)cOwnedPathNameAssignment_2.eContents().get(0);
		private final Assignment cIsAllAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cIsAllColonColonAsteriskKeyword_3_0 = (Keyword)cIsAllAssignment_3.eContents().get(0);
		
		//ImportCP base::ImportCS:
		//	('import' | 'domain') (name=Identifier ':')? ownedPathName=URIPathNameCS isAll?='::*'?;
		@Override public ParserRule getRule() { return rule; }
		
		//('import' | 'domain') (name=Identifier ':')? ownedPathName=URIPathNameCS isAll?='::*'?
		public Group getGroup() { return cGroup; }
		
		//'import' | 'domain'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'import'
		public Keyword getImportKeyword_0_0() { return cImportKeyword_0_0; }
		
		//'domain'
		public Keyword getDomainKeyword_0_1() { return cDomainKeyword_0_1; }
		
		//(name=Identifier ':')?
		public Group getGroup_1() { return cGroup_1; }
		
		//name=Identifier
		public Assignment getNameAssignment_1_0() { return cNameAssignment_1_0; }
		
		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_1_0_0() { return cNameIdentifierParserRuleCall_1_0_0; }
		
		//':'
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }
		
		//ownedPathName=URIPathNameCS
		public Assignment getOwnedPathNameAssignment_2() { return cOwnedPathNameAssignment_2; }
		
		//URIPathNameCS
		public RuleCall getOwnedPathNameURIPathNameCSParserRuleCall_2_0() { return cOwnedPathNameURIPathNameCSParserRuleCall_2_0; }
		
		//isAll?='::*'?
		public Assignment getIsAllAssignment_3() { return cIsAllAssignment_3; }
		
		//'::*'
		public Keyword getIsAllColonColonAsteriskKeyword_3_0() { return cIsAllColonColonAsteriskKeyword_3_0; }
	}
	public class RelationCPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cpl.CPL.RelationCP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhereKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_2_0 = (Alternatives)cGroup_2.eContents().get(0);
		private final Keyword cOrKeyword_2_0_0 = (Keyword)cAlternatives_2_0.eContents().get(0);
		private final Keyword cAndKeyword_2_0_1 = (Keyword)cAlternatives_2_0.eContents().get(1);
		private final Assignment cOwnedConditionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOwnedConditionsConditionCSParserRuleCall_2_1_0 = (RuleCall)cOwnedConditionsAssignment_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//RelationCP:
		//	'where' '{' (('or' | 'and')? ownedConditions+=ConditionCS)+
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'where' '{' (('or' | 'and')? ownedConditions+=ConditionCS)+ '}'
		public Group getGroup() { return cGroup; }
		
		//'where'
		public Keyword getWhereKeyword_0() { return cWhereKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//(('or' | 'and')? ownedConditions+=ConditionCS)+
		public Group getGroup_2() { return cGroup_2; }
		
		//('or' | 'and')?
		public Alternatives getAlternatives_2_0() { return cAlternatives_2_0; }
		
		//'or'
		public Keyword getOrKeyword_2_0_0() { return cOrKeyword_2_0_0; }
		
		//'and'
		public Keyword getAndKeyword_2_0_1() { return cAndKeyword_2_0_1; }
		
		//ownedConditions+=ConditionCS
		public Assignment getOwnedConditionsAssignment_2_1() { return cOwnedConditionsAssignment_2_1; }
		
		//ConditionCS
		public RuleCall getOwnedConditionsConditionCSParserRuleCall_2_1_0() { return cOwnedConditionsConditionCSParserRuleCall_2_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class MessageCPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cpl.CPL.MessageCP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMessageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOwnedExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOwnedExpressionSTRINGTerminalRuleCall_2_0 = (RuleCall)cOwnedExpressionAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//MessageCP:
		//	'message' '{' ownedExpression=STRING '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'message' '{' ownedExpression=STRING '}'
		public Group getGroup() { return cGroup; }
		
		//'message'
		public Keyword getMessageKeyword_0() { return cMessageKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//ownedExpression=STRING
		public Assignment getOwnedExpressionAssignment_2() { return cOwnedExpressionAssignment_2; }
		
		//STRING
		public RuleCall getOwnedExpressionSTRINGTerminalRuleCall_2_0() { return cOwnedExpressionSTRINGTerminalRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class ConditionCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cpl.CPL.ConditionCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOwnedElementAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOwnedElementAFQNParserRuleCall_0_0 = (RuleCall)cOwnedElementAAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cIsEquivalentKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cIsContradictKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		private final Keyword cLessThanSignKeyword_1_3 = (Keyword)cAlternatives_1.eContents().get(3);
		private final Keyword cEqualsSignEqualsSignKeyword_1_4 = (Keyword)cAlternatives_1.eContents().get(4);
		private final Keyword cLessThanSignGreaterThanSignKeyword_1_5 = (Keyword)cAlternatives_1.eContents().get(5);
		private final Keyword cExclamationMarkKeyword_1_6 = (Keyword)cAlternatives_1.eContents().get(6);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_7 = (Keyword)cAlternatives_1.eContents().get(7);
		private final Keyword cEqualsSignLessThanSignKeyword_1_8 = (Keyword)cAlternatives_1.eContents().get(8);
		private final Keyword cINKeyword_1_9 = (Keyword)cAlternatives_1.eContents().get(9);
		private final Keyword cNotINKeyword_1_10 = (Keyword)cAlternatives_1.eContents().get(10);
		private final Assignment cOwnedElementBAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOwnedElementBFQNParserRuleCall_2_0 = (RuleCall)cOwnedElementBAssignment_2.eContents().get(0);
		
		//ConditionCS:
		//	ownedElementA=FQN? ('isEquivalent' | 'isContradict' | '>' | '<' | '==' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN')?
		//	ownedElementB=FQN;
		@Override public ParserRule getRule() { return rule; }
		
		//ownedElementA=FQN? ('isEquivalent' | 'isContradict' | '>' | '<' | '==' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN')?
		//ownedElementB=FQN
		public Group getGroup() { return cGroup; }
		
		//ownedElementA=FQN?
		public Assignment getOwnedElementAAssignment_0() { return cOwnedElementAAssignment_0; }
		
		//FQN
		public RuleCall getOwnedElementAFQNParserRuleCall_0_0() { return cOwnedElementAFQNParserRuleCall_0_0; }
		
		//('isEquivalent' | 'isContradict' | '>' | '<' | '==' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN')?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'isEquivalent'
		public Keyword getIsEquivalentKeyword_1_0() { return cIsEquivalentKeyword_1_0; }
		
		//'isContradict'
		public Keyword getIsContradictKeyword_1_1() { return cIsContradictKeyword_1_1; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_1_2() { return cGreaterThanSignKeyword_1_2; }
		
		//'<'
		public Keyword getLessThanSignKeyword_1_3() { return cLessThanSignKeyword_1_3; }
		
		//'=='
		public Keyword getEqualsSignEqualsSignKeyword_1_4() { return cEqualsSignEqualsSignKeyword_1_4; }
		
		//'<>'
		public Keyword getLessThanSignGreaterThanSignKeyword_1_5() { return cLessThanSignGreaterThanSignKeyword_1_5; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_1_6() { return cExclamationMarkKeyword_1_6; }
		
		//'>='
		public Keyword getGreaterThanSignEqualsSignKeyword_1_7() { return cGreaterThanSignEqualsSignKeyword_1_7; }
		
		//'=<'
		public Keyword getEqualsSignLessThanSignKeyword_1_8() { return cEqualsSignLessThanSignKeyword_1_8; }
		
		//'IN'
		public Keyword getINKeyword_1_9() { return cINKeyword_1_9; }
		
		//'NotIN'
		public Keyword getNotINKeyword_1_10() { return cNotINKeyword_1_10; }
		
		//ownedElementB=FQN
		public Assignment getOwnedElementBAssignment_2() { return cOwnedElementBAssignment_2; }
		
		//FQN
		public RuleCall getOwnedElementBFQNParserRuleCall_2_0() { return cOwnedElementBFQNParserRuleCall_2_0; }
	}
	public class FQNElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cpl.CPL.FQN");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cUnrestrictedNameParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cIDParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final RuleCall cUnrestrictedNameParserRuleCall_1_1_0 = (RuleCall)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cIDParserRuleCall_1_1_1 = (RuleCall)cAlternatives_1_1.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//FQN:
		//	(UnrestrictedName | ID) (("." | "->") (UnrestrictedName | ID) '('? ')'?)*;
		@Override public ParserRule getRule() { return rule; }
		
		//(UnrestrictedName | ID) (("." | "->") (UnrestrictedName | ID) '('? ')'?)*
		public Group getGroup() { return cGroup; }
		
		//UnrestrictedName | ID
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_0_0() { return cUnrestrictedNameParserRuleCall_0_0; }
		
		//ID
		public RuleCall getIDParserRuleCall_0_1() { return cIDParserRuleCall_0_1; }
		
		//(("." | "->") (UnrestrictedName | ID) '('? ')'?)*
		public Group getGroup_1() { return cGroup_1; }
		
		//"." | "->"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//"."
		public Keyword getFullStopKeyword_1_0_0() { return cFullStopKeyword_1_0_0; }
		
		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_0_1() { return cHyphenMinusGreaterThanSignKeyword_1_0_1; }
		
		//UnrestrictedName | ID
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//UnrestrictedName
		public RuleCall getUnrestrictedNameParserRuleCall_1_1_0() { return cUnrestrictedNameParserRuleCall_1_1_0; }
		
		//ID
		public RuleCall getIDParserRuleCall_1_1_1() { return cIDParserRuleCall_1_1_1; }
		
		//'('?
		public Keyword getLeftParenthesisKeyword_1_2() { return cLeftParenthesisKeyword_1_2; }
		
		//')'?
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	
	
	private final TopLevelCPElements pTopLevelCP;
	private final ImportCPElements pImportCP;
	private final RelationCPElements pRelationCP;
	private final MessageCPElements pMessageCP;
	private final ConditionCSElements pConditionCS;
	private final FQNElements pFQN;
	private final TerminalRule tSTRING;
	
	private final Grammar grammar;
	
	private final CompleteOCLGrammarAccess gaCompleteOCL;
	
	private final EssentialOCLGrammarAccess gaEssentialOCL;
	
	private final BaseGrammarAccess gaBase;

	@Inject
	public CPLGrammarAccess(GrammarProvider grammarProvider,
			CompleteOCLGrammarAccess gaCompleteOCL,
			EssentialOCLGrammarAccess gaEssentialOCL,
			BaseGrammarAccess gaBase) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaCompleteOCL = gaCompleteOCL;
		this.gaEssentialOCL = gaEssentialOCL;
		this.gaBase = gaBase;
		this.pTopLevelCP = new TopLevelCPElements();
		this.pImportCP = new ImportCPElements();
		this.pRelationCP = new RelationCPElements();
		this.pMessageCP = new MessageCPElements();
		this.pConditionCS = new ConditionCSElements();
		this.pFQN = new FQNElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.cpl.CPL.STRING");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.cpl.CPL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public CompleteOCLGrammarAccess getCompleteOCLGrammarAccess() {
		return gaCompleteOCL;
	}
	
	public EssentialOCLGrammarAccess getEssentialOCLGrammarAccess() {
		return gaEssentialOCL;
	}
	
	public BaseGrammarAccess getBaseGrammarAccess() {
		return gaBase;
	}

	
	//TopLevelCP:
	//	'conflict' name=Identifier '{'
	//	ownedImports+=ImportCP+ ('inmodel' UnrestrictedName '{' ownedContexts+=ContextDeclCS+ '}')+
	//	ownedRelation+=RelationCP?
	//	ownedMessage+=MessageCP?
	//	'}';
	public TopLevelCPElements getTopLevelCPAccess() {
		return pTopLevelCP;
	}
	
	public ParserRule getTopLevelCPRule() {
		return getTopLevelCPAccess().getRule();
	}
	
	//ImportCP base::ImportCS:
	//	('import' | 'domain') (name=Identifier ':')? ownedPathName=URIPathNameCS isAll?='::*'?;
	public ImportCPElements getImportCPAccess() {
		return pImportCP;
	}
	
	public ParserRule getImportCPRule() {
		return getImportCPAccess().getRule();
	}
	
	//RelationCP:
	//	'where' '{' (('or' | 'and')? ownedConditions+=ConditionCS)+
	//	'}';
	public RelationCPElements getRelationCPAccess() {
		return pRelationCP;
	}
	
	public ParserRule getRelationCPRule() {
		return getRelationCPAccess().getRule();
	}
	
	//MessageCP:
	//	'message' '{' ownedExpression=STRING '}';
	public MessageCPElements getMessageCPAccess() {
		return pMessageCP;
	}
	
	public ParserRule getMessageCPRule() {
		return getMessageCPAccess().getRule();
	}
	
	//ConditionCS:
	//	ownedElementA=FQN? ('isEquivalent' | 'isContradict' | '>' | '<' | '==' | '<>' | '!' | '>=' | '=<' | 'IN' | 'NotIN')?
	//	ownedElementB=FQN;
	public ConditionCSElements getConditionCSAccess() {
		return pConditionCS;
	}
	
	public ParserRule getConditionCSRule() {
		return getConditionCSAccess().getRule();
	}
	
	//FQN:
	//	(UnrestrictedName | ID) (("." | "->") (UnrestrictedName | ID) '('? ')'?)*;
	public FQNElements getFQNAccess() {
		return pFQN;
	}
	
	public ParserRule getFQNRule() {
		return getFQNAccess().getRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	///*
	// * A Complete OCL document comprises
	// * bullet[model imports for referenced and complemented models]
	// * bullet[includes for additional Complete OCL documents]
	// * bullet[libraries to augment or override the OCL Standard Library]
	// * bullet[package declarations for package-grouped declarations]
	// * bullet[context declarations for independent declarations]
	// */
	//CompleteOCLDocumentCS:
	//	ownedImports+=ImportCS* (ownedPackages+=PackageDeclarationCS | ownedContexts+=ContextDeclCS)*;
	public CompleteOCLGrammarAccess.CompleteOCLDocumentCSElements getCompleteOCLDocumentCSAccess() {
		return gaCompleteOCL.getCompleteOCLDocumentCSAccess();
	}
	
	public ParserRule getCompleteOCLDocumentCSRule() {
		return getCompleteOCLDocumentCSAccess().getRule();
	}
	
	//terminal UNQUOTED_STRING: // Never forward parsed; just provides a placeholder
	// '£$%^£$%^'
	//	//  for reverse serialisation of embedded OCL 
	//;
	public TerminalRule getUNQUOTED_STRINGRule() {
		return gaCompleteOCL.getUNQUOTED_STRINGRule();
	}
	
	//CompleteOCLNavigationOperatorName:
	//	'^' | '^^';
	public CompleteOCLGrammarAccess.CompleteOCLNavigationOperatorNameElements getCompleteOCLNavigationOperatorNameAccess() {
		return gaCompleteOCL.getCompleteOCLNavigationOperatorNameAccess();
	}
	
	public ParserRule getCompleteOCLNavigationOperatorNameRule() {
		return getCompleteOCLNavigationOperatorNameAccess().getRule();
	}
	
	//ClassifierContextDeclCS:
	//	'context' ownedSignature=TemplateSignatureCS? selfName=UnrestrictedName? ownedPathName=PathNameCS ('inv'
	//	ownedInvariants+=ConstraintCS | ownedDefinitions+=DefCS)+;
	public CompleteOCLGrammarAccess.ClassifierContextDeclCSElements getClassifierContextDeclCSAccess() {
		return gaCompleteOCL.getClassifierContextDeclCSAccess();
	}
	
	public ParserRule getClassifierContextDeclCSRule() {
		return getClassifierContextDeclCSAccess().getRule();
	}
	
	///*
	// * A Constraint such as 
	// * 
	// * oclText[IsNull('should be null') : self = null]
	// * 
	// * comprises at least the OCL specification of the constraint. The constraint may
	// * additionally have a name which may be followed by a parenthesized expression defining an OCL
	// * expression to be evaluated to provide an error message.
	// */
	//ConstraintCS base::ConstraintCS:
	//	(name=UnrestrictedName ('(' ownedMessageSpecification=SpecificationCS ')')?)? ':' ownedSpecification=SpecificationCS;
	public CompleteOCLGrammarAccess.ConstraintCSElements getConstraintCSAccess() {
		return gaCompleteOCL.getConstraintCSAccess();
	}
	
	public ParserRule getConstraintCSRule() {
		return getConstraintCSAccess().getRule();
	}
	
	///*
	// * A Context declaration can be a Classifier, Operation of Property Context declaration.
	// */ ContextDeclCS:
	//	PropertyContextDeclCS | ClassifierContextDeclCS | OperationContextDeclCS;
	public CompleteOCLGrammarAccess.ContextDeclCSElements getContextDeclCSAccess() {
		return gaCompleteOCL.getContextDeclCSAccess();
	}
	
	public ParserRule getContextDeclCSRule() {
		return getContextDeclCSAccess().getRule();
	}
	
	///*
	// * A definition can be an, Operation or Property definition.
	// */ DefCS:
	//	DefOperationCS | DefPropertyCS;
	public CompleteOCLGrammarAccess.DefCSElements getDefCSAccess() {
		return gaCompleteOCL.getDefCSAccess();
	}
	
	public ParserRule getDefCSRule() {
		return getDefCSAccess().getRule();
	}
	
	///*
	// * An operation definition provides an additional operation for its classifier context.
	// * 
	// * oclText[static def redundantName: isEven(i : Integer) : Boolean = i mod 2 = 0]
	// * 
	// * comprises at least an operation name, return type and an OCL expression that evaluates the operation value.
	// * The operation may have parameters and may be declared static in which case there is no oclText[self].
	// * 
	// * For compatibility with invariants the definition may have a name that is never used.
	// */
	//DefOperationCS:
	//	isStatic?='static'? 'def' UnrestrictedName? ':' ownedSignature=TemplateSignatureCS? name=UnrestrictedName '('
	//	(ownedParameters+=DefParameterCS (',' ownedParameters+=DefParameterCS)*)? ')' ':' ownedType=TypeExpCS? '='
	//	ownedSpecification=SpecificationCS;
	public CompleteOCLGrammarAccess.DefOperationCSElements getDefOperationCSAccess() {
		return gaCompleteOCL.getDefOperationCSAccess();
	}
	
	public ParserRule getDefOperationCSRule() {
		return getDefOperationCSAccess().getRule();
	}
	
	//DefParameterCS base::ParameterCS:
	//	name=UnrestrictedName ':' ownedType=TypeExpCS;
	public CompleteOCLGrammarAccess.DefParameterCSElements getDefParameterCSAccess() {
		return gaCompleteOCL.getDefParameterCSAccess();
	}
	
	public ParserRule getDefParameterCSRule() {
		return getDefParameterCSAccess().getRule();
	}
	
	///*
	// * A property definition provides an additional property for its classifier context.
	// * 
	// * oclText[static def redundantName: upperCaseName : Boolean = name.toUpperCase()]
	// * 
	// * comprises at least a property name, type and an OCL expression that evaluates the property value.
	// * The property may be declared static in which case there is no oclText[self].
	// * 
	// * For compatibility with invariants the definition may have a name that is never used.
	// */
	//DefPropertyCS:
	//	isStatic?='static'? 'def' UnrestrictedName? ':' name=UnrestrictedName ':' ownedType=TypeExpCS '='
	//	ownedSpecification=SpecificationCS;
	public CompleteOCLGrammarAccess.DefPropertyCSElements getDefPropertyCSAccess() {
		return gaCompleteOCL.getDefPropertyCSAccess();
	}
	
	public ParserRule getDefPropertyCSRule() {
		return getDefPropertyCSAccess().getRule();
	}
	
	//ImportCS base::ImportCS:
	//	('import' | 'include' | 'library') (name=Identifier ':')? ownedPathName=URIPathNameCS isAll?='::*'?;
	public CompleteOCLGrammarAccess.ImportCSElements getImportCSAccess() {
		return gaCompleteOCL.getImportCSAccess();
	}
	
	public ParserRule getImportCSRule() {
		return getImportCSAccess().getRule();
	}
	
	///*
	// * An operation context declaration complements an existing operation with additional details.
	// * 
	// * oclText[context (T) Stack::pop() : T]
	// * oclText[pre NotEmptyPop: size() > 0]
	// * oclText[post: size()@pre = size() + 1]
	// * 
	// * The operation declaration comprises at least an operation name, which must be qualified with at least a
	// * class name. If used outside a package declaration, package name qualification is also needed. 
	// * If the return type is omitted OclVoid is used.
	// * The operation may also have operation parameters and template parameters.
	// * The declaration may be followed by any number of preconditions,
	// * and/or postconditions. It may also be followed by a body expression that defines the evaluation. 
	// * 
	// * For compatibility with invariants the body expression may have a name that is never used.
	// */
	//OperationContextDeclCS:
	//	'context' ownedSignature=TemplateSignatureCS? ownedPathName=PathNameCS '(' (ownedParameters+=ParameterCS (','
	//	ownedParameters+=ParameterCS)*)? ')' ':' ownedType=TypeExpCS? ('pre' ownedPreconditions+=ConstraintCS | 'post'
	//	ownedPostconditions+=ConstraintCS | 'body' UnrestrictedName? ':' ownedBodies+=SpecificationCS)*;
	public CompleteOCLGrammarAccess.OperationContextDeclCSElements getOperationContextDeclCSAccess() {
		return gaCompleteOCL.getOperationContextDeclCSAccess();
	}
	
	public ParserRule getOperationContextDeclCSRule() {
		return getOperationContextDeclCSAccess().getRule();
	}
	
	//PackageDeclarationCS:
	//	'package' ownedPathName=PathNameCS ('inv' ownedInvariants+=ConstraintCS)* ownedContexts+=ContextDeclCS* 'endpackage';
	public CompleteOCLGrammarAccess.PackageDeclarationCSElements getPackageDeclarationCSAccess() {
		return gaCompleteOCL.getPackageDeclarationCSAccess();
	}
	
	public ParserRule getPackageDeclarationCSRule() {
		return getPackageDeclarationCSAccess().getRule();
	}
	
	//ParameterCS base::ParameterCS:
	//	(name=UnrestrictedName ':')? ownedType=TypeExpCS;
	public CompleteOCLGrammarAccess.ParameterCSElements getParameterCSAccess() {
		return gaCompleteOCL.getParameterCSAccess();
	}
	
	public ParserRule getParameterCSRule() {
		return getParameterCSAccess().getRule();
	}
	
	///*
	// * A property context declaration complements an existing property with additional details.
	// * 
	// * oclText[context (T) Stack::isEmpty : Boolean]
	// * oclText[derive IsEmpty: size() = 0]
	// * 
	// * The property declaration comprises at least a property name and type.
	// * The type must be qualified with at least a class name.
	// * If used outside a package declaration, package name qualification is also needed. 
	// * The declaration may be followed by a derive constraint and/or an init expression.
	// * 
	// * A derive constraint provides an alternate mechanism for defining a class invariant;
	// * the only difference is that the property is identified as a constrainedElement. As an
	// * invariant the constraint provides an OCL expression that should always be true.
	// * 
	// * For a non-derived property, an init expression defines the value to be assigned to the property
	// * when its containing object is first created. 
	// * 
	// * For a derived property, an init expression defines the evaluation of the property, which
	// * may vary from access to access even for read-only properties.
	// * 
	// * NB. RoyalAndLoyal gratuitously names its derived values.
	// */
	//PropertyContextDeclCS:
	//	'context' ownedPathName=PathNameCS ':' ownedType=TypeExpCS ('derive' UnrestrictedName? ':'
	//	ownedDefaultExpressions+=SpecificationCS | 'init' UnrestrictedName? ':' ownedDefaultExpressions+=SpecificationCS)*;
	public CompleteOCLGrammarAccess.PropertyContextDeclCSElements getPropertyContextDeclCSAccess() {
		return gaCompleteOCL.getPropertyContextDeclCSAccess();
	}
	
	public ParserRule getPropertyContextDeclCSRule() {
		return getPropertyContextDeclCSAccess().getRule();
	}
	
	//SpecificationCS essentialocl::ExpSpecificationCS:
	//	ownedExpression=ExpCS | exprString=UNQUOTED_STRING;
	public CompleteOCLGrammarAccess.SpecificationCSElements getSpecificationCSAccess() {
		return gaCompleteOCL.getSpecificationCSAccess();
	}
	
	public ParserRule getSpecificationCSRule() {
		return getSpecificationCSAccess().getRule();
	}
	
	////---------------------------------------------------------------------------------
	// //	Base overrides
	//
	////---------------------------------------------------------------------------------
	// TemplateSignatureCS
	//base::TemplateSignatureCS:
	//	'(' ownedParameters+=TypeParameterCS (',' ownedParameters+=TypeParameterCS)* ')' | '<'
	//	ownedParameters+=TypeParameterCS (',' ownedParameters+=TypeParameterCS)* '>';
	public CompleteOCLGrammarAccess.TemplateSignatureCSElements getTemplateSignatureCSAccess() {
		return gaCompleteOCL.getTemplateSignatureCSAccess();
	}
	
	public ParserRule getTemplateSignatureCSRule() {
		return getTemplateSignatureCSAccess().getRule();
	}
	
	//TypedRefCS base::TypedRefCS:
	//	TypeLiteralCS | TypedTypeRefCS;
	public CompleteOCLGrammarAccess.TypedRefCSElements getTypedRefCSAccess() {
		return gaCompleteOCL.getTypedRefCSAccess();
	}
	
	public ParserRule getTypedRefCSRule() {
		return getTypedRefCSAccess().getRule();
	}
	
	//UnrestrictedName:
	//	EssentialOCLUnrestrictedName //| 'body'
	// //| 'context'
	// //| 'def'
	// //| 'derive'
	// //|	'endpackage'
	// | 'import' |
	//	'include' //| 'init'
	// //| 'inv'
	// | 'library' //|	'package'
	// //|	'post'
	// //|	'pre'
	// //|	'static'
	//;
	public CompleteOCLGrammarAccess.UnrestrictedNameElements getUnrestrictedNameAccess() {
		return gaCompleteOCL.getUnrestrictedNameAccess();
	}
	
	public ParserRule getUnrestrictedNameRule() {
		return getUnrestrictedNameAccess().getRule();
	}
	
	////---------------------------------------------------------------------------------
	// //	EssentialOCL overrides
	//
	////---------------------------------------------------------------------------------
	// NavigatingArgExpCS
	//essentialocl::ExpCS:
	//	{OCLMessageArgCS} '?' | ExpCS;
	public CompleteOCLGrammarAccess.NavigatingArgExpCSElements getNavigatingArgExpCSAccess() {
		return gaCompleteOCL.getNavigatingArgExpCSAccess();
	}
	
	public ParserRule getNavigatingArgExpCSRule() {
		return getNavigatingArgExpCSAccess().getRule();
	}
	
	//NavigationOperatorName:
	//	EssentialOCLNavigationOperatorName | CompleteOCLNavigationOperatorName;
	public CompleteOCLGrammarAccess.NavigationOperatorNameElements getNavigationOperatorNameAccess() {
		return gaCompleteOCL.getNavigationOperatorNameAccess();
	}
	
	public ParserRule getNavigationOperatorNameRule() {
		return getNavigationOperatorNameAccess().getRule();
	}
	
	//PrimitiveTypeIdentifier:
	//	'Boolean' | 'Integer' | 'Real' | 'String' | 'UnlimitedNatural' | 'OclAny' | 'OclInvalid' | 'OclMessage' | 'OclState'
	//	| 'OclVoid';
	public CompleteOCLGrammarAccess.PrimitiveTypeIdentifierElements getPrimitiveTypeIdentifierAccess() {
		return gaCompleteOCL.getPrimitiveTypeIdentifierAccess();
	}
	
	public ParserRule getPrimitiveTypeIdentifierRule() {
		return getPrimitiveTypeIdentifierAccess().getRule();
	}
	
	////generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
	// Model ContextCS:
	//	ownedExpression=ExpCS;
	public EssentialOCLGrammarAccess.ModelElements getModelAccess() {
		return gaEssentialOCL.getModelAccess();
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLReservedKeyword:
	//	'and' | 'and2' | 'else' | 'endif' | 'if' | 'implies' | 'implies2' | 'in' | 'let' | 'not' | 'not2' | 'or' | 'or2' |
	//	'then' | 'xor' | 'xor2';
	public EssentialOCLGrammarAccess.EssentialOCLReservedKeywordElements getEssentialOCLReservedKeywordAccess() {
		return gaEssentialOCL.getEssentialOCLReservedKeywordAccess();
	}
	
	public ParserRule getEssentialOCLReservedKeywordRule() {
		return getEssentialOCLReservedKeywordAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLUnaryOperatorName:
	//	'-' | 'not' | 'not2';
	public EssentialOCLGrammarAccess.EssentialOCLUnaryOperatorNameElements getEssentialOCLUnaryOperatorNameAccess() {
		return gaEssentialOCL.getEssentialOCLUnaryOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLUnaryOperatorNameRule() {
		return getEssentialOCLUnaryOperatorNameAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLInfixOperatorName:
	//	'*' | '/' | '+' | '-' | '>' | '<' | '>=' | '<=' | '=' | '<>' | 'and' | 'and2' | 'implies' | 'implies2' | 'or' | 'or2'
	//	| 'xor' | 'xor2';
	public EssentialOCLGrammarAccess.EssentialOCLInfixOperatorNameElements getEssentialOCLInfixOperatorNameAccess() {
		return gaEssentialOCL.getEssentialOCLInfixOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLInfixOperatorNameRule() {
		return getEssentialOCLInfixOperatorNameAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLNavigationOperatorName:
	//	'.' | '->' | '?.' | '?->';
	public EssentialOCLGrammarAccess.EssentialOCLNavigationOperatorNameElements getEssentialOCLNavigationOperatorNameAccess() {
		return gaEssentialOCL.getEssentialOCLNavigationOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLNavigationOperatorNameRule() {
		return getEssentialOCLNavigationOperatorNameAccess().getRule();
	}
	
	//BinaryOperatorName:
	//	InfixOperatorName | super::NavigationOperatorName;
	public EssentialOCLGrammarAccess.BinaryOperatorNameElements getBinaryOperatorNameAccess() {
		return gaEssentialOCL.getBinaryOperatorNameAccess();
	}
	
	public ParserRule getBinaryOperatorNameRule() {
		return getBinaryOperatorNameAccess().getRule();
	}
	
	//InfixOperatorName:
	//	EssentialOCLInfixOperatorName;
	public EssentialOCLGrammarAccess.InfixOperatorNameElements getInfixOperatorNameAccess() {
		return gaEssentialOCL.getInfixOperatorNameAccess();
	}
	
	public ParserRule getInfixOperatorNameRule() {
		return getInfixOperatorNameAccess().getRule();
	}
	
	//UnaryOperatorName:
	//	EssentialOCLUnaryOperatorName;
	public EssentialOCLGrammarAccess.UnaryOperatorNameElements getUnaryOperatorNameAccess() {
		return gaEssentialOCL.getUnaryOperatorNameAccess();
	}
	
	public ParserRule getUnaryOperatorNameRule() {
		return getUnaryOperatorNameAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	// //  Names
	//
	////---------------------------------------------------------------------
	//
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLUnrestrictedName:
	//	Identifier;
	public EssentialOCLGrammarAccess.EssentialOCLUnrestrictedNameElements getEssentialOCLUnrestrictedNameAccess() {
		return gaEssentialOCL.getEssentialOCLUnrestrictedNameAccess();
	}
	
	public ParserRule getEssentialOCLUnrestrictedNameRule() {
		return getEssentialOCLUnrestrictedNameAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLUnreservedName:
	//	super::UnrestrictedName | CollectionTypeIdentifier | super::PrimitiveTypeIdentifier | 'Map' | 'Tuple';
	public EssentialOCLGrammarAccess.EssentialOCLUnreservedNameElements getEssentialOCLUnreservedNameAccess() {
		return gaEssentialOCL.getEssentialOCLUnreservedNameAccess();
	}
	
	public ParserRule getEssentialOCLUnreservedNameRule() {
		return getEssentialOCLUnreservedNameAccess().getRule();
	}
	
	//UnreservedName:
	//	EssentialOCLUnreservedName;
	public EssentialOCLGrammarAccess.UnreservedNameElements getUnreservedNameAccess() {
		return gaEssentialOCL.getUnreservedNameAccess();
	}
	
	public ParserRule getUnreservedNameRule() {
		return getUnreservedNameAccess().getRule();
	}
	
	//URIPathNameCS base::PathNameCS:
	//	ownedPathElements+=URIFirstPathElementCS ('::' ownedPathElements+=NextPathElementCS)*;
	public EssentialOCLGrammarAccess.URIPathNameCSElements getURIPathNameCSAccess() {
		return gaEssentialOCL.getURIPathNameCSAccess();
	}
	
	public ParserRule getURIPathNameCSRule() {
		return getURIPathNameCSAccess().getRule();
	}
	
	//URIFirstPathElementCS base::PathElementCS:
	//	referredElement=[pivot::NamedElement|super::UnrestrictedName] | {base::PathElementWithURICS}
	//	referredElement=[pivot::Namespace|URI];
	public EssentialOCLGrammarAccess.URIFirstPathElementCSElements getURIFirstPathElementCSAccess() {
		return gaEssentialOCL.getURIFirstPathElementCSAccess();
	}
	
	public ParserRule getURIFirstPathElementCSRule() {
		return getURIFirstPathElementCSAccess().getRule();
	}
	
	//SimplePathNameCS base::PathNameCS:
	//	ownedPathElements+=FirstPathElementCS;
	public EssentialOCLGrammarAccess.SimplePathNameCSElements getSimplePathNameCSAccess() {
		return gaEssentialOCL.getSimplePathNameCSAccess();
	}
	
	public ParserRule getSimplePathNameCSRule() {
		return getSimplePathNameCSAccess().getRule();
	}
	
	//PrimitiveTypeCS base::PrimitiveTypeRefCS:
	//	name=super::PrimitiveTypeIdentifier;
	public EssentialOCLGrammarAccess.PrimitiveTypeCSElements getPrimitiveTypeCSAccess() {
		return gaEssentialOCL.getPrimitiveTypeCSAccess();
	}
	
	public ParserRule getPrimitiveTypeCSRule() {
		return getPrimitiveTypeCSAccess().getRule();
	}
	
	//CollectionTypeIdentifier:
	//	'Set' | 'Bag' | 'Sequence' | 'Collection' | 'OrderedSet';
	public EssentialOCLGrammarAccess.CollectionTypeIdentifierElements getCollectionTypeIdentifierAccess() {
		return gaEssentialOCL.getCollectionTypeIdentifierAccess();
	}
	
	public ParserRule getCollectionTypeIdentifierRule() {
		return getCollectionTypeIdentifierAccess().getRule();
	}
	
	//CollectionTypeCS:
	//	name=CollectionTypeIdentifier ('(' ownedType=TypeExpWithoutMultiplicityCS ownedCollectionMultiplicity=MultiplicityCS?
	//	')')?;
	public EssentialOCLGrammarAccess.CollectionTypeCSElements getCollectionTypeCSAccess() {
		return gaEssentialOCL.getCollectionTypeCSAccess();
	}
	
	public ParserRule getCollectionTypeCSRule() {
		return getCollectionTypeCSAccess().getRule();
	}
	
	//MapTypeCS:
	//	name='Map' ('(' ownedKeyType=TypeExpCS ',' ownedValueType=TypeExpCS ')')?;
	public EssentialOCLGrammarAccess.MapTypeCSElements getMapTypeCSAccess() {
		return gaEssentialOCL.getMapTypeCSAccess();
	}
	
	public ParserRule getMapTypeCSRule() {
		return getMapTypeCSAccess().getRule();
	}
	
	//TupleTypeCS base::TupleTypeCS:
	//	name='Tuple' ('(' (ownedParts+=TuplePartCS (',' ownedParts+=TuplePartCS)*)? ')')?;
	public EssentialOCLGrammarAccess.TupleTypeCSElements getTupleTypeCSAccess() {
		return gaEssentialOCL.getTupleTypeCSAccess();
	}
	
	public ParserRule getTupleTypeCSRule() {
		return getTupleTypeCSAccess().getRule();
	}
	
	//TuplePartCS base::TuplePartCS:
	//	name=super::UnrestrictedName ':' ownedType=TypeExpCS;
	public EssentialOCLGrammarAccess.TuplePartCSElements getTuplePartCSAccess() {
		return gaEssentialOCL.getTuplePartCSAccess();
	}
	
	public ParserRule getTuplePartCSRule() {
		return getTuplePartCSAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	// //  Literals
	//
	////---------------------------------------------------------------------
	// CollectionLiteralExpCS:
	//	ownedType=CollectionTypeCS '{' (ownedParts+=CollectionLiteralPartCS (',' ownedParts+=CollectionLiteralPartCS)*)? '}';
	public EssentialOCLGrammarAccess.CollectionLiteralExpCSElements getCollectionLiteralExpCSAccess() {
		return gaEssentialOCL.getCollectionLiteralExpCSAccess();
	}
	
	public ParserRule getCollectionLiteralExpCSRule() {
		return getCollectionLiteralExpCSAccess().getRule();
	}
	
	//CollectionLiteralPartCS:
	//	ownedExpression=ExpCS ('..' ownedLastExpression=ExpCS)? | ownedExpression=PatternExpCS;
	public EssentialOCLGrammarAccess.CollectionLiteralPartCSElements getCollectionLiteralPartCSAccess() {
		return gaEssentialOCL.getCollectionLiteralPartCSAccess();
	}
	
	public ParserRule getCollectionLiteralPartCSRule() {
		return getCollectionLiteralPartCSAccess().getRule();
	}
	
	//CollectionPatternCS:
	//	ownedType=CollectionTypeCS '{' (ownedParts+=PatternExpCS (',' ownedParts+=PatternExpCS)* ('++'
	//	restVariableName=Identifier))? '}';
	public EssentialOCLGrammarAccess.CollectionPatternCSElements getCollectionPatternCSAccess() {
		return gaEssentialOCL.getCollectionPatternCSAccess();
	}
	
	public ParserRule getCollectionPatternCSRule() {
		return getCollectionPatternCSAccess().getRule();
	}
	
	//ShadowPartCS:
	//	referredProperty=[pivot::Property|super::UnrestrictedName] '=' ownedInitExpression=(ExpCS | PatternExpCS) |
	//	ownedInitExpression=StringLiteralExpCS;
	public EssentialOCLGrammarAccess.ShadowPartCSElements getShadowPartCSAccess() {
		return gaEssentialOCL.getShadowPartCSAccess();
	}
	
	public ParserRule getShadowPartCSRule() {
		return getShadowPartCSAccess().getRule();
	}
	
	//PatternExpCS:
	//	patternVariableName=super::UnrestrictedName? ':' ownedPatternType=TypeExpCS;
	public EssentialOCLGrammarAccess.PatternExpCSElements getPatternExpCSAccess() {
		return gaEssentialOCL.getPatternExpCSAccess();
	}
	
	public ParserRule getPatternExpCSRule() {
		return getPatternExpCSAccess().getRule();
	}
	
	//LambdaLiteralExpCS:
	//	'Lambda' '{' ownedExpressionCS=ExpCS '}';
	public EssentialOCLGrammarAccess.LambdaLiteralExpCSElements getLambdaLiteralExpCSAccess() {
		return gaEssentialOCL.getLambdaLiteralExpCSAccess();
	}
	
	public ParserRule getLambdaLiteralExpCSRule() {
		return getLambdaLiteralExpCSAccess().getRule();
	}
	
	//MapLiteralExpCS:
	//	ownedType=MapTypeCS '{' (ownedParts+=MapLiteralPartCS (',' ownedParts+=MapLiteralPartCS)*)? '}';
	public EssentialOCLGrammarAccess.MapLiteralExpCSElements getMapLiteralExpCSAccess() {
		return gaEssentialOCL.getMapLiteralExpCSAccess();
	}
	
	public ParserRule getMapLiteralExpCSRule() {
		return getMapLiteralExpCSAccess().getRule();
	}
	
	//MapLiteralPartCS:
	//	ownedKey=ExpCS '<-' ownedValue=ExpCS;
	public EssentialOCLGrammarAccess.MapLiteralPartCSElements getMapLiteralPartCSAccess() {
		return gaEssentialOCL.getMapLiteralPartCSAccess();
	}
	
	public ParserRule getMapLiteralPartCSRule() {
		return getMapLiteralPartCSAccess().getRule();
	}
	
	//PrimitiveLiteralExpCS:
	//	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS | UnlimitedNaturalLiteralExpCS | InvalidLiteralExpCS |
	//	NullLiteralExpCS;
	public EssentialOCLGrammarAccess.PrimitiveLiteralExpCSElements getPrimitiveLiteralExpCSAccess() {
		return gaEssentialOCL.getPrimitiveLiteralExpCSAccess();
	}
	
	public ParserRule getPrimitiveLiteralExpCSRule() {
		return getPrimitiveLiteralExpCSAccess().getRule();
	}
	
	//TupleLiteralExpCS:
	//	'Tuple' '{' ownedParts+=TupleLiteralPartCS (',' ownedParts+=TupleLiteralPartCS)* '}';
	public EssentialOCLGrammarAccess.TupleLiteralExpCSElements getTupleLiteralExpCSAccess() {
		return gaEssentialOCL.getTupleLiteralExpCSAccess();
	}
	
	public ParserRule getTupleLiteralExpCSRule() {
		return getTupleLiteralExpCSAccess().getRule();
	}
	
	//TupleLiteralPartCS:
	//	name=super::UnrestrictedName (':' ownedType=TypeExpCS)? '=' ownedInitExpression=ExpCS;
	public EssentialOCLGrammarAccess.TupleLiteralPartCSElements getTupleLiteralPartCSAccess() {
		return gaEssentialOCL.getTupleLiteralPartCSAccess();
	}
	
	public ParserRule getTupleLiteralPartCSRule() {
		return getTupleLiteralPartCSAccess().getRule();
	}
	
	//NumberLiteralExpCS:
	//	symbol=NUMBER_LITERAL;
	public EssentialOCLGrammarAccess.NumberLiteralExpCSElements getNumberLiteralExpCSAccess() {
		return gaEssentialOCL.getNumberLiteralExpCSAccess();
	}
	
	public ParserRule getNumberLiteralExpCSRule() {
		return getNumberLiteralExpCSAccess().getRule();
	}
	
	//StringLiteralExpCS:
	//	segments+=StringLiteral+;
	public EssentialOCLGrammarAccess.StringLiteralExpCSElements getStringLiteralExpCSAccess() {
		return gaEssentialOCL.getStringLiteralExpCSAccess();
	}
	
	public ParserRule getStringLiteralExpCSRule() {
		return getStringLiteralExpCSAccess().getRule();
	}
	
	//BooleanLiteralExpCS:
	//	symbol='true' | symbol='false';
	public EssentialOCLGrammarAccess.BooleanLiteralExpCSElements getBooleanLiteralExpCSAccess() {
		return gaEssentialOCL.getBooleanLiteralExpCSAccess();
	}
	
	public ParserRule getBooleanLiteralExpCSRule() {
		return getBooleanLiteralExpCSAccess().getRule();
	}
	
	//UnlimitedNaturalLiteralExpCS:
	//	{UnlimitedNaturalLiteralExpCS} '*';
	public EssentialOCLGrammarAccess.UnlimitedNaturalLiteralExpCSElements getUnlimitedNaturalLiteralExpCSAccess() {
		return gaEssentialOCL.getUnlimitedNaturalLiteralExpCSAccess();
	}
	
	public ParserRule getUnlimitedNaturalLiteralExpCSRule() {
		return getUnlimitedNaturalLiteralExpCSAccess().getRule();
	}
	
	//InvalidLiteralExpCS:
	//	{InvalidLiteralExpCS} 'invalid';
	public EssentialOCLGrammarAccess.InvalidLiteralExpCSElements getInvalidLiteralExpCSAccess() {
		return gaEssentialOCL.getInvalidLiteralExpCSAccess();
	}
	
	public ParserRule getInvalidLiteralExpCSRule() {
		return getInvalidLiteralExpCSAccess().getRule();
	}
	
	//NullLiteralExpCS:
	//	{NullLiteralExpCS} 'null';
	public EssentialOCLGrammarAccess.NullLiteralExpCSElements getNullLiteralExpCSAccess() {
		return gaEssentialOCL.getNullLiteralExpCSAccess();
	}
	
	public ParserRule getNullLiteralExpCSRule() {
		return getNullLiteralExpCSAccess().getRule();
	}
	
	//TypeLiteralCS base::TypedRefCS:
	//	PrimitiveTypeCS | CollectionTypeCS | MapTypeCS | TupleTypeCS;
	public EssentialOCLGrammarAccess.TypeLiteralCSElements getTypeLiteralCSAccess() {
		return gaEssentialOCL.getTypeLiteralCSAccess();
	}
	
	public ParserRule getTypeLiteralCSRule() {
		return getTypeLiteralCSAccess().getRule();
	}
	
	//TypeLiteralWithMultiplicityCS base::TypedRefCS:
	//	TypeLiteralCS ownedMultiplicity=MultiplicityCS?;
	public EssentialOCLGrammarAccess.TypeLiteralWithMultiplicityCSElements getTypeLiteralWithMultiplicityCSAccess() {
		return gaEssentialOCL.getTypeLiteralWithMultiplicityCSAccess();
	}
	
	public ParserRule getTypeLiteralWithMultiplicityCSRule() {
		return getTypeLiteralWithMultiplicityCSAccess().getRule();
	}
	
	//TypeLiteralExpCS:
	//	ownedType=TypeLiteralWithMultiplicityCS;
	public EssentialOCLGrammarAccess.TypeLiteralExpCSElements getTypeLiteralExpCSAccess() {
		return gaEssentialOCL.getTypeLiteralExpCSAccess();
	}
	
	public ParserRule getTypeLiteralExpCSRule() {
		return getTypeLiteralExpCSAccess().getRule();
	}
	
	//TypeNameExpCS:
	//	ownedPathName=PathNameCS (ownedCurlyBracketedClause=CurlyBracketedClauseCS ('{' ownedPatternGuard=ExpCS '}')?)?;
	public EssentialOCLGrammarAccess.TypeNameExpCSElements getTypeNameExpCSAccess() {
		return gaEssentialOCL.getTypeNameExpCSAccess();
	}
	
	public ParserRule getTypeNameExpCSRule() {
		return getTypeNameExpCSAccess().getRule();
	}
	
	//TypeExpWithoutMultiplicityCS base::TypedRefCS:
	//	TypeNameExpCS | TypeLiteralCS | CollectionPatternCS;
	public EssentialOCLGrammarAccess.TypeExpWithoutMultiplicityCSElements getTypeExpWithoutMultiplicityCSAccess() {
		return gaEssentialOCL.getTypeExpWithoutMultiplicityCSAccess();
	}
	
	public ParserRule getTypeExpWithoutMultiplicityCSRule() {
		return getTypeExpWithoutMultiplicityCSAccess().getRule();
	}
	
	//TypeExpCS base::TypedRefCS:
	//	TypeExpWithoutMultiplicityCS ownedMultiplicity=MultiplicityCS?;
	public EssentialOCLGrammarAccess.TypeExpCSElements getTypeExpCSAccess() {
		return gaEssentialOCL.getTypeExpCSAccess();
	}
	
	public ParserRule getTypeExpCSRule() {
		return getTypeExpCSAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	// //  Expressions
	//
	////---------------------------------------------------------------------
	//
	//// An ExpCS permits a LetExpCS only in the final term to ensure
	//
	////  that let is right associative, whereas infix operators are left associative.
	//
	////   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
	// // is
	//
	////   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
	//
	///* An expression elaborates a prefixed expression with zero or more binary operator and expression suffixes.
	// * An optionally prefixed let expression is permitted except when suffixed with further expressions.*/
	//ExpCS:
	//	PrefixedPrimaryExpCS ({InfixExpCS.ownedLeft=current} name=BinaryOperatorName ownedRight=ExpCS)? | PrefixedLetExpCS;
	public EssentialOCLGrammarAccess.ExpCSElements getExpCSAccess() {
		return gaEssentialOCL.getExpCSAccess();
	}
	
	public ParserRule getExpCSRule() {
		return getExpCSAccess().getRule();
	}
	
	///* A prefixed let expression elaborates a let expression with zero or more unary prefix operators. */ PrefixedLetExpCS
	//ExpCS:
	//	{PrefixExpCS} name=UnaryOperatorName ownedRight=PrefixedLetExpCS | LetExpCS;
	public EssentialOCLGrammarAccess.PrefixedLetExpCSElements getPrefixedLetExpCSAccess() {
		return gaEssentialOCL.getPrefixedLetExpCSAccess();
	}
	
	public ParserRule getPrefixedLetExpCSRule() {
		return getPrefixedLetExpCSAccess().getRule();
	}
	
	///* A prefixed primary expression elaborates a primary expression with zero or more unary prefix operators. */
	//PrefixedPrimaryExpCS ExpCS:
	//	{PrefixExpCS} name=UnaryOperatorName ownedRight=PrefixedPrimaryExpCS | PrimaryExpCS;
	public EssentialOCLGrammarAccess.PrefixedPrimaryExpCSElements getPrefixedPrimaryExpCSAccess() {
		return gaEssentialOCL.getPrefixedPrimaryExpCSAccess();
	}
	
	public ParserRule getPrefixedPrimaryExpCSRule() {
		return getPrefixedPrimaryExpCSAccess().getRule();
	}
	
	///* A primary expression identifies the basic expressions from which more complex expressions may be constructed. */
	//PrimaryExpCS ExpCS:
	//	NestedExpCS | IfExpCS | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS | MapLiteralExpCS |
	//	CollectionLiteralExpCS | LambdaLiteralExpCS | TypeLiteralExpCS | NameExpCS;
	public EssentialOCLGrammarAccess.PrimaryExpCSElements getPrimaryExpCSAccess() {
		return gaEssentialOCL.getPrimaryExpCSAccess();
	}
	
	public ParserRule getPrimaryExpCSRule() {
		return getPrimaryExpCSAccess().getRule();
	}
	
	///* A name expression is a generalised rule for expressions that start with a name and which may be followed by square, round or
	// * curly bracket clauses and optionally an @pre as well.*/
	//NameExpCS:
	//	ownedPathName=PathNameCS ownedSquareBracketedClauses+=SquareBracketedClauseCS*
	//	ownedRoundBracketedClause=RoundBracketedClauseCS? ownedCurlyBracketedClause=CurlyBracketedClauseCS? (isPre?='@'
	//	'pre')?;
	public EssentialOCLGrammarAccess.NameExpCSElements getNameExpCSAccess() {
		return gaEssentialOCL.getNameExpCSAccess();
	}
	
	public ParserRule getNameExpCSRule() {
		return getNameExpCSAccess().getRule();
	}
	
	///* A curly bracket clause is a generalized rule for the literal arguments of collections, maps, tuples and shadows.*/
	//CurlyBracketedClauseCS:
	//	{CurlyBracketedClauseCS} '{' (ownedParts+=ShadowPartCS (',' ownedParts+=ShadowPartCS)*)? '}';
	public EssentialOCLGrammarAccess.CurlyBracketedClauseCSElements getCurlyBracketedClauseCSAccess() {
		return gaEssentialOCL.getCurlyBracketedClauseCSAccess();
	}
	
	public ParserRule getCurlyBracketedClauseCSRule() {
		return getCurlyBracketedClauseCSAccess().getRule();
	}
	
	///* A curly bracket clause is a generalized rule for template specialisations and operations arguments.*/
	//RoundBracketedClauseCS:
	//	{RoundBracketedClauseCS} '(' (ownedArguments+=NavigatingArgCS ownedArguments+=(NavigatingCommaArgCS |
	//	NavigatingSemiArgCS | NavigatingBarArgCS)*)? ')';
	public EssentialOCLGrammarAccess.RoundBracketedClauseCSElements getRoundBracketedClauseCSAccess() {
		return gaEssentialOCL.getRoundBracketedClauseCSAccess();
	}
	
	public ParserRule getRoundBracketedClauseCSRule() {
		return getRoundBracketedClauseCSAccess().getRule();
	}
	
	///* A square bracket clause is a generalized rule for association class qualifiers and roles.*/ SquareBracketedClauseCS:
	//	'[' ownedTerms+=ExpCS (',' ownedTerms+=ExpCS)* ']';
	public EssentialOCLGrammarAccess.SquareBracketedClauseCSElements getSquareBracketedClauseCSAccess() {
		return gaEssentialOCL.getSquareBracketedClauseCSAccess();
	}
	
	public ParserRule getSquareBracketedClauseCSRule() {
		return getSquareBracketedClauseCSAccess().getRule();
	}
	
	///* A navigating argument is a generalized rule for the first argument in a round bracket clause. This is typically the first operation
	// * parameter or an iterator. */
	//NavigatingArgCS:
	//	ownedNameExpression=super::NavigatingArgExpCS ('<-' ownedCoIterator=CoIteratorVariableCS ('='
	//	ownedInitExpression=ExpCS)? | ':' ownedType=TypeExpCS ('<-' ownedCoIterator=CoIteratorVariableCS)? ('='
	//	ownedInitExpression=ExpCS)? | (':' ownedType=TypeExpCS)? ('<-' ownedCoIterator=CoIteratorVariableCS)? 'in'
	//	ownedInitExpression=ExpCS)? | ':' ownedType=TypeExpCS;
	public EssentialOCLGrammarAccess.NavigatingArgCSElements getNavigatingArgCSAccess() {
		return gaEssentialOCL.getNavigatingArgCSAccess();
	}
	
	public ParserRule getNavigatingArgCSRule() {
		return getNavigatingArgCSAccess().getRule();
	}
	
	//// Type-less init is an illegal infix expression
	//
	///* A navigating bar argument is a generalized rule for a bar-prefixed argument in a round bracket clause. This is typically the body of an iteration. */
	//NavigatingBarArgCS NavigatingArgCS:
	//	prefix='|' ownedNameExpression=super::NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' ownedInitExpression=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingBarArgCSElements getNavigatingBarArgCSAccess() {
		return gaEssentialOCL.getNavigatingBarArgCSAccess();
	}
	
	public ParserRule getNavigatingBarArgCSRule() {
		return getNavigatingBarArgCSAccess().getRule();
	}
	
	//// Type-less init is an illegal infix expression
	//
	///* A navigating comma argument is a generalized rule for non-first argument in a round bracket clause. These are typically non-first operation
	// * parameters or a second iterator. */
	//NavigatingCommaArgCS NavigatingArgCS:
	//	prefix=',' ownedNameExpression=super::NavigatingArgExpCS ('<-' ownedCoIterator=CoIteratorVariableCS ('='
	//	ownedInitExpression=ExpCS)? | ':' ownedType=TypeExpCS ('<-' ownedCoIterator=CoIteratorVariableCS)? ('='
	//	ownedInitExpression=ExpCS)? | (':' ownedType=TypeExpCS)? ('<-' ownedCoIterator=CoIteratorVariableCS)? 'in'
	//	ownedInitExpression=ExpCS)?;
	public EssentialOCLGrammarAccess.NavigatingCommaArgCSElements getNavigatingCommaArgCSAccess() {
		return gaEssentialOCL.getNavigatingCommaArgCSAccess();
	}
	
	public ParserRule getNavigatingCommaArgCSRule() {
		return getNavigatingCommaArgCSAccess().getRule();
	}
	
	//// Type-less init is an illegal infix expression
	//
	///* A navigating semi argument is a generalized rule for a semicolon prefixed argument in a round bracket clause. This is typically an iterate accumulator. */
	//NavigatingSemiArgCS NavigatingArgCS:
	//	prefix=';' ownedNameExpression=super::NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' ownedInitExpression=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingSemiArgCSElements getNavigatingSemiArgCSAccess() {
		return gaEssentialOCL.getNavigatingSemiArgCSAccess();
	}
	
	public ParserRule getNavigatingSemiArgCSRule() {
		return getNavigatingSemiArgCSAccess().getRule();
	}
	
	//CoIteratorVariableCS VariableCS:
	//	name=super::UnrestrictedName (':' ownedType=TypeExpCS)?;
	public EssentialOCLGrammarAccess.CoIteratorVariableCSElements getCoIteratorVariableCSAccess() {
		return gaEssentialOCL.getCoIteratorVariableCSAccess();
	}
	
	public ParserRule getCoIteratorVariableCSRule() {
		return getCoIteratorVariableCSAccess().getRule();
	}
	
	//IfExpCS:
	//	'if' ownedCondition=(ExpCS | PatternExpCS) 'then' ownedThenExpression=ExpCS //	ifThenExpressions+=IfThenExpCS
	//
	//	ownedIfThenExpressions+=ElseIfThenExpCS* 'else' ownedElseExpression=ExpCS 'endif';
	public EssentialOCLGrammarAccess.IfExpCSElements getIfExpCSAccess() {
		return gaEssentialOCL.getIfExpCSAccess();
	}
	
	public ParserRule getIfExpCSRule() {
		return getIfExpCSAccess().getRule();
	}
	
	////IfThenExpCS returns IfThenExpCS:
	// //	'if' condition=ExpCS
	// //	'then' thenExpression=ExpCS
	// //;
	// ElseIfThenExpCS
	//IfThenExpCS:
	//	'elseif' ownedCondition=ExpCS 'then' ownedThenExpression=ExpCS;
	public EssentialOCLGrammarAccess.ElseIfThenExpCSElements getElseIfThenExpCSAccess() {
		return gaEssentialOCL.getElseIfThenExpCSAccess();
	}
	
	public ParserRule getElseIfThenExpCSRule() {
		return getElseIfThenExpCSAccess().getRule();
	}
	
	//LetExpCS:
	//	'let' ownedVariables+=LetVariableCS (',' ownedVariables+=LetVariableCS)* 'in' ownedInExpression=ExpCS;
	public EssentialOCLGrammarAccess.LetExpCSElements getLetExpCSAccess() {
		return gaEssentialOCL.getLetExpCSAccess();
	}
	
	public ParserRule getLetExpCSRule() {
		return getLetExpCSAccess().getRule();
	}
	
	//LetVariableCS:
	//	name=super::UnrestrictedName ownedRoundBracketedClause=RoundBracketedClauseCS? (':' ownedType=TypeExpCS)? '='
	//	ownedInitExpression=ExpCS;
	public EssentialOCLGrammarAccess.LetVariableCSElements getLetVariableCSAccess() {
		return gaEssentialOCL.getLetVariableCSAccess();
	}
	
	public ParserRule getLetVariableCSRule() {
		return getLetVariableCSAccess().getRule();
	}
	
	//NestedExpCS:
	//	'(' ownedExpression=ExpCS ')';
	public EssentialOCLGrammarAccess.NestedExpCSElements getNestedExpCSAccess() {
		return gaEssentialOCL.getNestedExpCSAccess();
	}
	
	public ParserRule getNestedExpCSRule() {
		return getNestedExpCSAccess().getRule();
	}
	
	//SelfExpCS:
	//	{SelfExpCS} 'self';
	public EssentialOCLGrammarAccess.SelfExpCSElements getSelfExpCSAccess() {
		return gaEssentialOCL.getSelfExpCSAccess();
	}
	
	public ParserRule getSelfExpCSRule() {
		return getSelfExpCSAccess().getRule();
	}
	
	//MultiplicityBoundsCS:
	//	lowerBound=LOWER ('..' upperBound=UPPER)?;
	public BaseGrammarAccess.MultiplicityBoundsCSElements getMultiplicityBoundsCSAccess() {
		return gaBase.getMultiplicityBoundsCSAccess();
	}
	
	public ParserRule getMultiplicityBoundsCSRule() {
		return getMultiplicityBoundsCSAccess().getRule();
	}
	
	//MultiplicityCS:
	//	'[' (MultiplicityBoundsCS | MultiplicityStringCS) ('|?' | isNullFree?='|1')? ']';
	public BaseGrammarAccess.MultiplicityCSElements getMultiplicityCSAccess() {
		return gaBase.getMultiplicityCSAccess();
	}
	
	public ParserRule getMultiplicityCSRule() {
		return getMultiplicityCSAccess().getRule();
	}
	
	//MultiplicityStringCS:
	//	stringBounds=('*' | '+' | '?');
	public BaseGrammarAccess.MultiplicityStringCSElements getMultiplicityStringCSAccess() {
		return gaBase.getMultiplicityStringCSAccess();
	}
	
	public ParserRule getMultiplicityStringCSRule() {
		return getMultiplicityStringCSAccess().getRule();
	}
	
	//PathNameCS:
	//	ownedPathElements+=FirstPathElementCS ('::' ownedPathElements+=NextPathElementCS)*;
	public BaseGrammarAccess.PathNameCSElements getPathNameCSAccess() {
		return gaBase.getPathNameCSAccess();
	}
	
	public ParserRule getPathNameCSRule() {
		return getPathNameCSAccess().getRule();
	}
	
	//FirstPathElementCS PathElementCS:
	//	referredElement=[pivot::NamedElement|super::UnrestrictedName];
	public BaseGrammarAccess.FirstPathElementCSElements getFirstPathElementCSAccess() {
		return gaBase.getFirstPathElementCSAccess();
	}
	
	public ParserRule getFirstPathElementCSRule() {
		return getFirstPathElementCSAccess().getRule();
	}
	
	//NextPathElementCS PathElementCS:
	//	referredElement=[pivot::NamedElement|super::UnreservedName];
	public BaseGrammarAccess.NextPathElementCSElements getNextPathElementCSAccess() {
		return gaBase.getNextPathElementCSAccess();
	}
	
	public ParserRule getNextPathElementCSRule() {
		return getNextPathElementCSAccess().getRule();
	}
	
	//TemplateBindingCS:
	//	ownedSubstitutions+=TemplateParameterSubstitutionCS (',' ownedSubstitutions+=TemplateParameterSubstitutionCS)*
	//	ownedMultiplicity=MultiplicityCS?;
	public BaseGrammarAccess.TemplateBindingCSElements getTemplateBindingCSAccess() {
		return gaBase.getTemplateBindingCSAccess();
	}
	
	public ParserRule getTemplateBindingCSRule() {
		return getTemplateBindingCSAccess().getRule();
	}
	
	//TemplateParameterSubstitutionCS:
	//	ownedActualParameter=TypeRefCS;
	public BaseGrammarAccess.TemplateParameterSubstitutionCSElements getTemplateParameterSubstitutionCSAccess() {
		return gaBase.getTemplateParameterSubstitutionCSAccess();
	}
	
	public ParserRule getTemplateParameterSubstitutionCSRule() {
		return getTemplateParameterSubstitutionCSAccess().getRule();
	}
	
	//TypeParameterCS:
	//	name=super::UnrestrictedName ('extends' ownedExtends+=super::TypedRefCS ('&&' ownedExtends+=super::TypedRefCS)*)?;
	public BaseGrammarAccess.TypeParameterCSElements getTypeParameterCSAccess() {
		return gaBase.getTypeParameterCSAccess();
	}
	
	public ParserRule getTypeParameterCSRule() {
		return getTypeParameterCSAccess().getRule();
	}
	
	//TypeRefCS:
	//	super::TypedRefCS | WildcardTypeRefCS;
	public BaseGrammarAccess.TypeRefCSElements getTypeRefCSAccess() {
		return gaBase.getTypeRefCSAccess();
	}
	
	public ParserRule getTypeRefCSRule() {
		return getTypeRefCSAccess().getRule();
	}
	
	//TypedTypeRefCS:
	//	ownedPathName=PathNameCS ('(' ownedBinding=TemplateBindingCS ')')?;
	public BaseGrammarAccess.TypedTypeRefCSElements getTypedTypeRefCSAccess() {
		return gaBase.getTypedTypeRefCSAccess();
	}
	
	public ParserRule getTypedTypeRefCSRule() {
		return getTypedTypeRefCSAccess().getRule();
	}
	
	//WildcardTypeRefCS:
	//	{WildcardTypeRefCS} '?' ('extends' ownedExtends=super::TypedRefCS)?;
	public BaseGrammarAccess.WildcardTypeRefCSElements getWildcardTypeRefCSAccess() {
		return gaBase.getWildcardTypeRefCSAccess();
	}
	
	public ParserRule getWildcardTypeRefCSRule() {
		return getWildcardTypeRefCSAccess().getRule();
	}
	
	//ID:
	//	SIMPLE_ID | ESCAPED_ID;
	public BaseGrammarAccess.IDElements getIDAccess() {
		return gaBase.getIDAccess();
	}
	
	public ParserRule getIDRule() {
		return getIDAccess().getRule();
	}
	
	//Identifier:
	//	ID;
	public BaseGrammarAccess.IdentifierElements getIdentifierAccess() {
		return gaBase.getIdentifierAccess();
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}
	
	///* A lowerbounded integer is used to define the lowerbound of a collection multiplicity. The value may not be the unlimited value. */
	//LOWER ecore::EInt:
	//	INT;
	public BaseGrammarAccess.LOWERElements getLOWERAccess() {
		return gaBase.getLOWERAccess();
	}
	
	public ParserRule getLOWERRule() {
		return getLOWERAccess().getRule();
	}
	
	///* A number may be an integer or floating point value. The declaration here appears to be that for just an integer. This is to avoid
	// * lookahead conflicts in simple lexers between a dot within a floating point number and the dot-dot in a CollectionLiteralPartCS. A
	// * practical implementation should give high priority to a successful parse of INT ('.' INT)? (('e' | 'E') ('+' | '-')? INT)? than
	// * to the unsuccessful partial parse of INT '..'. The type of the INT terminal is String to allow the floating point syntax to be used.
	// */
	//NUMBER_LITERAL BigNumber:
	//	INT;
	public BaseGrammarAccess.NUMBER_LITERALElements getNUMBER_LITERALAccess() {
		return gaBase.getNUMBER_LITERALAccess();
	}
	
	public ParserRule getNUMBER_LITERALRule() {
		return getNUMBER_LITERALAccess().getRule();
	}
	
	//// EssentialOCLTokenSource pieces this together ('.' INT)? (('e' | 'E') ('+' | '-')? INT)?;
	// StringLiteral:
	//	SINGLE_QUOTED_STRING;
	public BaseGrammarAccess.StringLiteralElements getStringLiteralAccess() {
		return gaBase.getStringLiteralAccess();
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	///* An upperbounded integer is used to define the upperbound of a collection multiplicity. The value may be the unlimited value. */
	//UPPER ecore::EInt:
	//	INT | '*';
	public BaseGrammarAccess.UPPERElements getUPPERAccess() {
		return gaBase.getUPPERAccess();
	}
	
	public ParserRule getUPPERRule() {
		return getUPPERAccess().getRule();
	}
	
	//URI:
	//	SINGLE_QUOTED_STRING;
	public BaseGrammarAccess.URIElements getURIAccess() {
		return gaBase.getURIAccess();
	}
	
	public ParserRule getURIRule() {
		return getURIAccess().getRule();
	}
	
	//terminal fragment ESCAPED_CHARACTER:
	//	'\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\');
	public TerminalRule getESCAPED_CHARACTERRule() {
		return gaBase.getESCAPED_CHARACTERRule();
	}
	
	//terminal fragment LETTER_CHARACTER:
	//	'a'..'z' | 'A'..'Z' | '_';
	public TerminalRule getLETTER_CHARACTERRule() {
		return gaBase.getLETTER_CHARACTERRule();
	}
	
	//terminal DOUBLE_QUOTED_STRING:
	//	'"' (ESCAPED_CHARACTER | !('\\' | '"'))* '"';
	public TerminalRule getDOUBLE_QUOTED_STRINGRule() {
		return gaBase.getDOUBLE_QUOTED_STRINGRule();
	}
	
	//terminal SINGLE_QUOTED_STRING:
	//	"'" (ESCAPED_CHARACTER | !('\\' | "'"))* "'";
	public TerminalRule getSINGLE_QUOTED_STRINGRule() {
		return gaBase.getSINGLE_QUOTED_STRINGRule();
	}
	
	//terminal ML_SINGLE_QUOTED_STRING:
	//	"/'"->"'/";
	public TerminalRule getML_SINGLE_QUOTED_STRINGRule() {
		return gaBase.getML_SINGLE_QUOTED_STRINGRule();
	}
	
	//terminal SIMPLE_ID:
	//	LETTER_CHARACTER (LETTER_CHARACTER | '0'..'9')*;
	public TerminalRule getSIMPLE_IDRule() {
		return gaBase.getSIMPLE_IDRule();
	}
	
	//terminal ESCAPED_ID:
	//	"_" SINGLE_QUOTED_STRING;
	public TerminalRule getESCAPED_IDRule() {
		return gaBase.getESCAPED_IDRule();
	}
	
	//terminal INT:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaBase.getINTRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaBase.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'--' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaBase.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaBase.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaBase.getANY_OTHERRule();
	}
}
